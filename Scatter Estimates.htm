<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Property Estimates by Sq Ft scatter chart</title>
		<link rel="icon" href="favicon2.ico" type="image/x-icon" />
		<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script>
		<style>
			body {
				font-family: Arial, sans-serif;
				background-color: #f4f4f4;
				color: #333;
			}

			.chart-container {
				width: 80%;
				margin: auto;
				padding: 20px;
				border: 1px solid #ccc;
				border-radius: 10px;
				margin-top: 1em;
			}
			.checkbox-container {
				display: flex;
				justify-content: center;
				align-items: center;
				margin-bottom: 1em;
			}
			.checkbox-item {
				margin-right: 1em;
			}
			.stats {
				display: flex;
				justify-content: center;
				align-items: center;
				margin-bottom: 1em;
			}
		</style>
	</head>
	<body>
		<div class="checkbox-container">
			<div class="checkbox-item">
				<input type="checkbox" id="setA" name="setFilter" value="RE" checked />
				<label for="setA">RealEstimate</label>
			</div>
			<div class="checkbox-item">
				<input type="checkbox" id="setB" name="setFilter" value="ZE" unchecked />
				<label for="setB">Zestimate</label>
			</div>
			<div class="checkbox-item">
				<input type="checkbox" id="setOther" name="setFilter" value="OTHER" unchecked />
				<label for="setOther">Other</label>
			</div>

			<div class="checkbox-item">
				<input type="checkbox" id="lines" name="setFilter" value="RL" checked />
				<label for="line3">Reference Lines</label>
			</div>
		</div>
		<div class="stats"><p id="statistics"></p></div>
		<div class="chart-container">
			<canvas id="scatterChart"></canvas>
		</div>

		<script>
			console.log('Scatter chart with checkboxes');

			// HTML integrations
			const stats = document.getElementById('statistics');
			const ctx = document.getElementById('scatterChart').getContext('2d');
			const ChartOptions = 'input[name="setFilter"]'; // checkboxes for chart settings
			const RE = 'RE'; // checkbox value RealEstimate
			const ZE = 'ZE'; // checkbox value Zestimate
			const other = 'OTHER'; // checkbox value Other
			const RL = 'RL'; // checkbox value Referelecne Lines

			// Reference Lines 
			const AM = 'AM'; 
			const OLD = 'OLD'; 
			const NEW = 'NEW';
			const REAL = 'REAL';
			const AVG = ' Average'; // label suffex for RE or ZE average reference lines  

			// unique placeholder keys - the exact values don't matter
			const MINSF = 'minsf'; 
			const MAXSF = 'maxsf'; 

			const sets = { // strings and colors for chart datasets
				AM: { label: 'AlphaMap Avg', color: 'purple', note: 'AlphaMap.coma avg for 0.3 miles' },  
				RE: { label: 'RealEstimate', color: 'rgba(54, 179, 39, 0.8)', note: 'Realtor.com' }, 
				ZE: { label: 'Zestimate', color: 'rgba(95, 96, 26, 0.8)', note: 'Zillow.com'}, 
				OTHER: { label: 'Other Estimates', color: 'rgba(245, 170, 40, 0.6)', note: ''},
				OLD: { label: 'My old sqft', color: 'fuchsia', note: '1935 Assessment'}, 
				NEW: { label: 'My new sqft', color: 'red', note: '2024 Assessment'},  
				REAL: {label: 'My Assessment', color: 'blue', note: 'most acurate assessment'}, 		
				DEFAULT: { label: '(undefined)', color: 'rgba(150, 150, 150, 0.6)', note: ''},		
			}

			// label helper 
			function labelMap ( set ) {
				if ( sets[set].label) return( sets[set].label);
				else return sets.DEFAULT.label;
			}

			// color helper 
			function colorMap ( set ) {
				if ( sets[set].color) return( sets[set].color);
				else return sets.DEFAULT.color;
			}

			// historical sq ft values, fixed.
			const assessments = [
				[1116, OLD ], // main house footprint, 17% is in walls and the front porch
				[1766, NEW ], // main house + back room footprint, 15% is walls, porch, or outside the footprint
				[1944, REAL ], // finished living space for main house, back room, and upper level
			];
			const assessmentLines = assessments.map((item) => item[1]);
			console.log('Assessments: ', ...assessmentLines);
		
			// Property data
			// IMPORTANT: do not change properties{} structure 
			const properties = {
				records: [
					[984, 370000, '1022 Curran', ZE, '04/18/2025'],
					[984, 377600, '1022 Curran', RE, '04/18/2025'],
					[1725, 504000, '10th St', ZE, '04/18/2025 Townhouse'],

					[1631, 870100, '1176 Atlantic', other, '04/19/2025 Collateral Analytics'], // Collateral Analytics 2-month spike
					[1631, 595180, '1176 Atlantic', RE, '04/20/2025'], // Quantarium
					[1631, 540100, '1176 Atlantic', ZE, '04/19/2025'],

					[2038, 859900, '1171B State', RE, '04/19/2025'],
					[2038, 799900, '1171B State', RE, '05/22/2025'],
					[2038, 848200, '1171B State', ZE, '04/19/2025'],
					[2038, 804300, '1171B State', ZE, '05/22/2025'],
					[1375, 515000, '461 Trabert', ZE, '04/18/2025'],
					[1375, 533516, '461 Trabert', RE, '04/18/2025'],

					[1116, 851000, '1176 State', other, '04/15/2025 Collateral Analytics'], // 2nd month outlier for several days
					[1116, 327400, '1176 State', ZE, '03/27/2025'],
					[1116, 479900, '1176 State', RE, '04/18/2025'], // Hah! down 44% in 3 days
					[1766, 353900, '1176 State', ZE, '04/18/2025'],
					[1944, 680040, '1176 State', other, '$350/sqft'],
					[1766, 618100, '1176 State', other, '$350/sqft'],

					[1116, 423189, '1176 State', other, '05/11/2025 Redfin'],
					[1116, 557700, '1176 State', RE, '05/17/2025'], // Hah!  up 16% in 29 days

					[1052, 495200, '1175 State', RE, '04/19/2025'],
					[1052, 330800, '1175 State', ZE, '04/19/2025'],

					[1016, 488400, '1180 State', RE, '04/19/2025'],
					[1016, 384200, '1180 State', ZE, '04/19/2025'],

					[1276, 484180, '1186 State', RE, '04/19/2025'],
					[1276, 487400, '1186 State', ZE, '04/19/2025'],

					[2263, 578621, '1185 State', RE, '04/19/2025'], // Kevin and Stacey
					[2263, 538694, '1185 State', RE, '05/11/2025'], // sqft is no on Realtor.com
					[2263, 570257, '1185 State', other, '05/11/2025 Redfin'],
					[2263, 459900, '1185 State', ZE, '04/19/2025'],

					[1500, 570000, '1189 State', RE, '04/19/2025'],
					[1500, 622800, '1189 State', ZE, '04/19/2025'],

					[1715, 492949, '1190 State', RE, '04/19/2025'],
					[1495, 506400, '1190 State', ZE, '04/19/2025'],

					[2038, 643600, '1199 State', RE, '04/19/2025'],
					/* [2038, 610000, '1199 State', RE, '04/21/2025'],*/
					[2038, 613700, '1199 State', ZE, '04/19/2025'],

					[1715, 662200, '1190 Francis', RE, '04/19/2025'],
					[1715, 577400, '1190 Francis', ZE, '04/19/2025'],

					[1786, 889000, '1186B Francis', RE, '05/10/2025'],
					[1786, 871000, '1186B Francis', ZE, '05/10/2025'],

					[1608, 418000, '1170 Atlantic', RE, '04/20/2025'],

					[1888, 649900, '1190 Atlantic', ZE, '04/20/2025'],
					[1888, 649900, '1190 Atlantic', RE, '04/20/2025'], // 3/2 with 1 car garage

					[1362, 549250, '1229 State', RE, '05/03/2025'],
					[1362, 555700, '1229 State', ZE, '05/03/2025'],

					[1657, 641941, '1251 State', RE, '05/03/2025'],
					[1657, 586400, '1251 State', ZE, '05/03/2025'],

					[1353, 577000, '1244 Atlantic', RE, '05/03/2025'],
					[1353, 600000, '1244 Atlantic', ZE, '05/03/2025'],

					[1030, 421200, '1179 Mecaslin', ZE, '04/19/2025'],
					[1030, 434578, '1179 Mecaslin', RE, '04/19/2025'],

					[1050, 427572, '1185 Mecaslin', RE, '04/20/2025'],
				],
					// field positions in records[[array]]
					sqft: 0, value: 1, label: 2, set: 3, date: 4, 
			};

			// Reference lines for the scatter chart
			// IMPORTANT: structure mirrors properties{} 
			let lines = {
				records: [ // MINSF and MAXSF will get updated to reflect actual property data
					[ MINSF, 628739, '0.3 mi Avg', AM, '2024 data'], 
					[ MAXSF, 628739, '', AM, '2024 data'], // label intionally omitted  

					// more records will get appended by AddAssessmentReferenceLines()
				],
				// field positions in records[[array]]
				sqft: 0, value: 1, label: 2, set: 3, date: 4, 
			};

			// Averages for RE, ZE, Other will get calculated later
			// IMPORTANT: structure mirrors properties{} 
			let avgs = { 
				records: [],
				// field positions in records[[array]]
				sqft: 0, value: 1, label: 2, set: 3, date: 4, 
			};

			// Calculate reference lines from properties and and assessment data
			findSetAverages(properties);

			AddAssessmentReferenceLines();

			// Get unique set values from the lines data for legend and filtering
			//const lineSets = Array.from(new Set(lines.records.map((record) => record[lines.set])));
			//console.log('Reference Line sets: ', lineSets);
			console.log('Reference line data: ', lines.records);

			let scatterChart; // Declare the chart variable

			// Initial chart render with default selected sets
			updateChart();

			// Event listener for checkbox changes
			document.querySelectorAll(ChartOptions).forEach((checkbox) => {
				checkbox.addEventListener('change', function () {
					updateChart(); // Update chart whenever a checkbox changes
				});
			});

			function AddAssessmentReferenceLines(minSize = 800, maxSize = 2200) {
				/* these point will define a line of house values for each Price Per Square Foot (PPSF) */

				// Find the smallest and largest sqft values in the properties data
				const smallestSqft =
					1.0 * Math.min(...properties.records.map((record) => record[properties.sqft])).toPrecision(2);
				const largestSqft =
					1.0 * Math.max(...properties.records.map((record) => record[properties.sqft])).toPrecision(2);

				// Replace 'MINSF' and'MAXSF' placeholders with actual values. Only affects the AM set
				for (let i = 0; i < lines.records.length; i++) {
					if (lines.records[i][0] === 'MINSF') lines.records[i][0] = smallestSqft;
					if (lines.records[i][0] === 'MAXSF') lines.records[i][0] = largestSqft;
				}

				// Calculate average price per square foot (PPSF) from the avgs.records
				avgPPSF = avgs.records[0][avgs.value] / avgs.records[0][avgs.sqft];
				minVerticalrate = (0.7 * avgPPSF).toFixed(0); // 30% below average
				maxVerticalrate = (1.2 * avgPPSF).toFixed(0); // 20% above average

				//lines.records = []; // lines that go through to each assessment point

				// create datapoints to define vertical reference lines at each assessment size
				assessments.forEach((a) => {
					// vertical lines at each assessment size
					const sqft = a[0];
					const set = a[1];
					const minLabel = sets[set].label + ' at $' + minVerticalrate + '/sf';
					const maxLabel = sets[set].label + ' at $' + maxVerticalrate + '/sf';
					lines.records.push([sqft, sqft * minVerticalrate, sqft, set, minLabel]); // only label one end of line
					lines.records.push([sqft, sqft * maxVerticalrate, '', set, maxLabel]);
				});

				// Create datapoints for reference lines based on average PPSF and avgs.records
				avgs.records.forEach((record, index) => {
					const label = record[avgs.label];
					if ('' === label) {
						label = 'record ' & index;
					}

					const sqft = record[avgs.sqft];
					if (typeof sqft != 'number') {
						console.warn(`Invalid data, ${label} sqft ${sqft} is not a number`);
						return;
					}
					if (sqft <= 0) {
						console.warn(`Invalid data, ${label} sqft ${sqft} must be greater than zero`);
						return;
					}
					const value = record[avgs.value];
					if (typeof value != 'number') {
						console.warn(`Invalid data, ${label} value ${value} is not a number`);
						return;
					}

					const PPSF = (value / sqft).toPrecision(3); // Price Per Square Foot
					// console.log(`${label}: $${PPSF} per sqft`);
					lines.records.push([minSize, minSize * PPSF, '', label, PPSF]);
					lines.records.push([maxSize, maxSize * PPSF, label + ' at $' + PPSF, label, PPSF]);

				});
				console.log('Reference lines: ', lines.records);
			}

			function findSetAverages(properties) {
				// Find the average property values for each set
				const estimatesSets = [RE, ZE, other];
				estimatesSets.forEach((set) => {
					let setRecords;
					if (set === other) {
						// For 'Other', filter properties where set is neither RE nor 'ZE'
						setRecords = properties.records.filter(
							(record) => record[properties.set] !== RE && record[properties.set] !== ZE
						);
					} else {
						setRecords = properties.records.filter((record) => record[properties.set] === set);
					}

					if (setRecords.length > 0) {
						avgSqft = setRecords.reduce((sum, record) => sum + record[properties.sqft], 0);
						avgSqft = Math.round(avgSqft / setRecords.length);
						avgValue = setRecords.reduce((sum, record) => sum + record[properties.value], 0);
						avgValue = Math.round(avgValue / setRecords.length);
						avgs.records.push([avgSqft, avgValue, set, sets[set].label + AVG, '']);
					}
				});
				console.log('Set' + AVG, avgs.records);
			}

			function calculateAveragePropertyMetrics(properties, selectedSets) {
				if (!properties || !properties.records || properties.records.length === 0) {
					return { averageTax: 0, averageSqft: 0 };
				}

				let metrics = { sqft: 0, taxes: 0, value: 0, cnt: 0 };
				for (const record of properties.records) {
					// Check if the current record's set is directly selected
					if (selectedSets.includes(record[properties.set])) {
						metrics.sqft += record[properties.sqft];
						metrics.value += record[properties.value];
						metrics.cnt++;
					} else if (
						selectedSets.includes(other) &&
						record[properties.set] !== RE &&
						record[properties.set] !== ZE
					) {
						// If 'Other' is selected, include records that are not RE, 'ZE'
						metrics.sqft += record[properties.sqft];
						metrics.value += record[properties.value];
						metrics.cnt++;
					}
				}
				// Avoid division by zero
				const averageSqft = metrics.cnt > 0 ? metrics.sqft / metrics.cnt : 0;
				const averageValue = metrics.cnt > 0 ? metrics.value / metrics.cnt : 0;

				return {
					averageSqft: 1.0 * averageSqft.toPrecision(3),
					averageValue: 1.0 * averageValue.toPrecision(3),
				};
			}

			// helper for createScatterDataset()
			function isOtherSet(recordSet) {
					return recordSet !== RE && recordSet !== ZE;
			}
		
			function getOpaqueBorderColor(rgbaColor) {
				if (rgbaColor && rgbaColor.startsWith('rgba(')) {
					return rgbaColor.replace(/, [\d\.]+\)$/, ', 1)');
				}
				return rgbaColor;
			}

			// config helper for updateChart() 
			function createScatterDataset(setType) {
				let filteredData = [];
				if (setType === other) {
					filteredData = properties.records.filter((record) => isOtherSet(record.set));
				} else {
					filteredData = properties.records.filter((record) => record.set === setType);
				}

				if (filteredData.length === 0) {
					console.warn ( 'no data filtered for scatter', setType );
					return null;
				}


				return {
					type: 'scatter',
					label: currentLabelMap[setType],
					data: filteredData.map((record) => ({
						x: record.sqft,
						y: record.value,
						label: record.label,
						date: record.date,
					})),
					backgroundColor: sets[setType].color,
					borderColor: (sets[setType].color).replace('0.8', '1'), // getOpaqueBorderColor(sets[setType].color)
					pointRadius: 5,
					pointHoverRadius: 8,
				};
			}

			// config helper for updateChart() 
			function createLineDataset( setType ) {
				const filteredLineData = lines.records.filter((record) => record.set === setType);
				if (filteredLineData.length === 0) {
					console.warn ( 'no data filtered for line', setType );
					return null;
				}
				return {
					type: 'line',
					label: labelText,
					data: filteredLineData.map((record) => ({
						x: parseFloat(record.sqft),
						y: parseFloat(record.value),
						label: record.label,
						date: record.date,
					})),
					fill: false,
					borderColor: sets[setType].color || sets.DEFAULT.color,
					backgroundColor: 'rgba(255, 255, 255, 0.8)',
					tension: 0,
					pointRadius: 1,
					borderWidth: 1,
					pointHoverRadius: 3,
					showLine: true,
				};
			}


			function updateChart() {
				const datasets = [];

				// Get all checked checkboxes
				const selectedSets = Array.from(document.querySelectorAll(ChartOptions+':checked')).map(
					(checkbox) => checkbox.value
				);
				console.log('checkboxes: ', selectedSets);

				// Add datasets for selected scatter points sets

				// Handle the main scatter points
				const scatterPointTypes = [RE, ZE]; // could add Redfin, etc.
				scatterPointTypes.forEach((set) => {
					if (selectedSets.includes(set)) {
						
						/* Refactor code idea in progress */
						const scatterData = createScatterDataset( set );
						if (scatterData) {
							datasets.push(scatterData);
						}
						else { // fallback while createScatterData(set) is broken
							datasets.push({
								type: 'scatter', // Explicit
								label: sets[set].label,
								data: properties.records
									.filter((record) => record[properties.set] === set)
									.map((record) => ({
										x: record[properties.sqft],
										y: record[properties.value],
										label: record[properties.label],
										date: record[properties.date],
									})),
								backgroundColor: sets[set].color,
								borderColor: (sets[set].color).replace('0.8', '1'), // getOpaqueBorderColor(sets[set].color)
								pointRadius: 5,
								pointHoverRadius: 8,
							}); 
						};
						// Check for a reference lines if RL checkbox is selected
						// IMPORTANT: reference line added here so the line legend appears immediately next to its corresponding scatter set legend
						// DO NOT MOVE or combine with the other RL handler further below 
						if (selectedSets.includes(RL)) {
							
							/* Refector idea */
							// const lineData = createLineDataset( set );  
							// if (lineData) datasets.push(lineData);
						
							const lineData = lines.records
								.filter((record) => record[lines.set] === set)
								.map((record) => ({
									x: parseFloat(record[lines.sqft]),
									y: parseFloat(record[lines.value]),
									label: record[lines.label],
								}));

							// add the reference line data corresponding to the this scatter point set
							if (lineData.length > 0) {
								datasets.push({
									type: 'line', // Explicitly set type to line
									label: sets[set].label + AVG, 
									data: lineData,
									fill: false, // no fill color in the area below the line
									borderColor: sets[set].color || sets.DEFAULT.color, 
									backgroundColor: 'rgba(255, 255, 255, 0.8)', // white fill, color only the legend border (line)
									tension: 0, // Straight lines
									pointRadius: 1,
									borderWidth: 1, // Line width
									pointHoverRadius: 1, // allow hover effect on points
									showLine: true, // Ensure the line is drawn
								});
								console.log('Added Reference line for ', sets[set].label + AVG);
							}
						}
					}
				});

				// Handle 'Other' scatter points, not RE and not ZE
				if (selectedSets.includes(other)) {
					const otherRecords = properties.records.filter(
						(record) => record[properties.set] !== RE && record[properties.set] !== ZE
					);
					if (otherRecords.length > 0) {
						datasets.push({
							type: 'scatter', // Explicit
							label: sets[other].label,
							data: otherRecords.map((record) => ({
								x: record[properties.sqft],
								y: record[properties.value],
								label: record[properties.label],
								date: record[properties.date],
							})),
							backgroundColor: sets.OTHER.color, 
							borderColor: sets.OTHER.color,  // replace with getOpaqueBorderColor(sets.OTHER.color)?
							pointRadius: 5,
							pointHoverRadius: 8,
						});
					}
				}

				// Handle the other reference lines if RL checkbox is selected
				if (selectedSets.includes( RL )) {
					// Add Assessments reference lines
					assessmentLines.forEach((set_value) => {
						console.log('Add reference line for ', sets[set_value].label); 

						const lineData = lines.records
							.filter((record) => record[lines.set] === set_value)
							.map((record) => ({
								x: parseFloat(record[lines.sqft]),
								y: parseFloat(record[lines.value]),
								label: record[lines.label],
							}));

						if (lineData.length > 0) {
							datasets.push({
								type: 'line', // Explicitly set type to line
								label: sets[set_value].label || sets.DEFAULT.label, 
								data: lineData,
								fill: false, // no fill color in the area below the line
								borderColor: sets[set_value].color || sets.DEFAULT.color, 
								backgroundColor: 'rgba(255, 255, 255, 0.8)', // white fill, color only the legend border (line)
								tension: 0, // Straight lines
								pointRadius: 1, //  points on the lines
								borderWidth: 1, // Line width
								pointHoverRadius: 3, //  hover effect on points
								showLine: true, // Ensure the line is drawn
							});
						}
					});
				}

				const config = {
					type: 'scatter',
					data: { datasets: datasets },
					options: {
						responsive: true,
						maintainAspectRatio: true,
						title: {
							display: true,
							text:
								datasets.length > 1
									? 'Sqft vs. Value'
									: datasets.length === 1
									? `Sqft vs. Value (${datasets[0].label})`
									: 'Sqft vs. Value',
							font: {
								size: 18,
								color: '#333',
							},
							padding: 10,
						},
						scales: {
							x: {
								type: 'linear',
								position: 'bottom',
								title: {
									display: true,
									text: 'Assessed Square Feet',
									fontColor: '#555',
									fontSize: 16,
									padding: 8,
								},
								ticks: {
									beginAtZero: true,
									font: {
										color: '#666',
									},
								},
							},
							y: {
								type: 'linear',
								position: 'left',
								title: {
									display: true,
									text: 'Estimated Value',
									fontColor: '#555',
									font: {
										size: 16,
										color: '#555',
									},
									padding: 8,
								},
								ticks: {
									beginAtZero: true,
									font: {
										color: '#666',
									},
									callback: function (value) {
										if (value >= 1000) {
											return (value / 1000).toFixed(0) + 'K';
										}
										return value.toLocaleString();
									},
								},
							},
						},
						plugins: {
							tooltip: {
								callbacks: {
									label: function (context) {
										let label = context.dataset.label || '';
										if (label) {
											label += ': ';
										}
										let price = context.parsed.y; // Use parsed.y for the numerical value
										if (price >= 1000) {
											label += `${context.parsed.x} sq ft for $${(price / 1000).toFixed(0)}K`;
										} else {
											label += `${context.parsed.x} sq ft for $${price.toLocaleString()})`;
										}
										// Add the specific point label if available (useful for reference lines)
										if (context.raw && context.raw.label) {
											label += ` - ${context.raw.label}`;
										}
										return label;
									},
									title: function (context) {
										// For scatter points, show the property label
										if (
											context[0].dataset.type === 'scatter' &&
											context[0].raw &&
											context[0].raw.label
										) {
											if (context[0].raw.date > '') return `${context[0].raw.date}`;
											else return `${context[0].raw.label}`;
										}
										// For line points, show the line label
										if (context[0].dataset.type === 'line') {
											return `Reference: ${context[0].dataset.label}`;
										}
										return ''; // Default empty title
									},
								},
								backgroundColor: 'rgba(0, 0, 0, 0.8)',
								titleFontColor: '#fff',
								bodyFontColor: '#eee',
								borderColor: '#333',
								borderWidth: 1,
								cornerRadius: 4,
								padding: 8,
							},
							legend: {
								display: true,
								position: 'top',
							},
							datalabels: {
								display: true,
							},
						},
					},
					plugins: [ChartDataLabels],
				};

				if (scatterChart) {
					scatterChart.destroy();
				}
				scatterChart = new Chart(ctx, config);

				let metrics = calculateAveragePropertyMetrics(properties, selectedSets);
				console.log('Metrics for selections: ', metrics);

				const ppsf = (metrics.averageValue / metrics.averageSqft).toPrecision(3);
				stats.innerHTML = 'Average [';
				stats.innerHTML += '$' + ppsf + '/sq ft, ';
				stats.innerHTML += '$' + (metrics.averageValue / 1000).toFixed(0) + 'K, ';
				stats.innerHTML += metrics.averageSqft + ' sq ft ]';
			}
		</script>
	</body>
</html>
