<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Property Estimates by Sq Ft scatter chart</title>
		<link rel="icon" href="favicon2.ico" type="image/x-icon" />
		<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script>
		<style>
			body {
				font-family: Arial, sans-serif;
				background-color: #f4f4f4;
				color: #333;
				margin: 0; 
				padding: 1em; 
			}

			.chart-container {
				width: 80%;
				max-width: 1000px; 
				margin: 20px auto; 
				padding: 20px;
				border: 1px solid #ccc;
				border-radius: 10px;
				background-color: #fff; 
			}

			.checkbox-container {
				display: flex;
				flex-wrap: wrap; 
				justify-content: center;
				align-items: center;
				margin-bottom: 1em;
				padding: 10px;
				background-color: #fff;
				border-radius: 8px;
				box-shadow: 0 2px 4px rgba(0,0,0,0.1);
			}

			.checkbox-item {
				margin: 0.5em 1em; 
			}

			.stats {
				display: flex;
				justify-content: center;
				align-items: center;
				margin-bottom: 1em;
				padding: 10px;
				background-color: #e9ecef;
				border-radius: 8px;
				font-weight: bold;
			}
		</style>
	</head>
	<body>
		<!-- Checkbox controls for filtering chart data -->
		<div class="checkbox-container">
			<div class="checkbox-item">
				<input type="checkbox" id="setA" name="setFilter" value="RE" checked />
				<label for="setA">RealEstimate</label>
			</div>
			<div class="checkbox-item">
				<input type="checkbox" id="setB" name="setFilter" value="ZE" unchecked />
				<label for="setB">Zestimate</label>
			</div>
			<div class="checkbox-item">
				<input type="checkbox" id="setOther" name="setFilter" value="OTHER" unchecked />
				<label for="setOther">Other</label>
			</div>
			<div class="checkbox-item">
				<input type="checkbox" id="lines" name="setFilter" value="RL" checked />
				<label for="line3">Reference Lines</label>
			</div>
		</div>

		<!-- Statistics display area -->
		<div class="stats"><p id="statisticsOutputElement">Average [N/A]</p></div>

		<!-- Chart canvas container -->
		<div class="chart-container">
			<canvas id="scatterChartCanvas"></canvas>
		</div>

		<script>
			// Log script initialization for debugging.
			console.log('Scatter chart script initialized.');

			// --- HTML Element References ---
			const statsOutputElement = document.getElementById('statisticsOutputElement'); 
			const chartCanvasContext = document.getElementById('scatterChartCanvas').getContext('2d'); 
			const chartFilterCheckboxes = 'input[name="setFilter"]'; // CSS selector for chart filter checkboxes

			// --- Constant Definitions ---

			// Defines values used by checkboxes to control data visibility.
			const CheckboxValues = {
				RE: 'RE',       // RealEstimate dataset
				ZE: 'ZE',       // Zestimate dataset
				OTHER: 'OTHER', // Other estimate sources dataset
				RL: 'RL'        // Toggle for all reference lines
			};

			// Defines types/keys for different reference lines that can be drawn on the chart.
			const ReferenceLineTypes = {
				AM: 'AM',     // AlphaMap neighborhood average line
				OLD: 'OLD',   // Line representing property's old assessment sq ft
				NEW: 'NEW',   // Line representing property's new assessment sq ft
				REAL: 'REAL'  // Line representing property's most accurate/current assessment sq ft
			};

			const AVG_SUFFIX = ' Average'; // Suffix for legend labels of lines representing averages (e.g., "RealEstimate Average")
			const MIN_SQFT_PLACEHOLDER = 'minsf_placeholder'; // Placeholder string for minimum sq ft in lines.records
			const MAX_SQFT_PLACEHOLDER = 'maxsf_placeholder'; // Placeholder string for maximum sq ft in lines.records

			// Configuration for chart datasets: labels, colors, and notes for different data series.
			// Keys are typically from CheckboxValues or ReferenceLineTypes.
			const sets = { 
				[ReferenceLineTypes.AM]: { label: 'AlphaMap Avg', color: 'purple', note: 'AlphaMap.com avg for 0.3 miles' },  
				[CheckboxValues.RE]: { label: 'RealEstimate', color: 'rgba(54, 179, 39, 0.8)', note: 'Realtor.com' }, 
				[CheckboxValues.ZE]: { label: 'Zestimate', color: 'rgba(95, 96, 26, 0.8)', note: 'Zillow.com'}, 
				[CheckboxValues.OTHER]: { label: 'Other Estimates', color: 'rgba(245, 170, 40, 0.6)', note: ''},
				[ReferenceLineTypes.OLD]: { label: 'My old sqft', color: 'fuchsia', note: '1935 Assessment, 1116 sqft' }, 
				[ReferenceLineTypes.NEW]: { label: 'My new sqft', color: 'red', note: '2024 Assessment, 1766 sqft' },  
				[ReferenceLineTypes.REAL]: {label: 'My Assessment', color: 'blue', note: 'Most accurate assessment, 1944 sqft'}, 		
				DEFAULT: { label: '(undefined)', color: 'rgba(150, 150, 150, 0.6)', note: ''},		
			};
			
			// --- Data Definitions ---

			// Defines different property assessment sizes (sqft) and their corresponding reference line types.
			// These are used to draw vertical reference lines at specific sqft values.
			const assessments = [
				{ sqft: 1116, set: ReferenceLineTypes.OLD, description: 'Main house footprint (1935)' }, 
				{ sqft: 1766, set: ReferenceLineTypes.NEW, description: 'Main house + back room footprint (2024)' }, 
				{ sqft: 1944, set: ReferenceLineTypes.REAL, description: 'Finished living space all levels' }, 
			];
			// Extracts the set keys for these assessment-based lines for easier iteration.
			const assessmentLineSetKeys = assessments.map(item => item.set);
			console.log('Assessment Line Set Keys:', ...assessmentLineSetKeys);
		
			// Property estimate data. Each record is an object representing a single estimate.
			// `label` is typically the property address. `set` indicates the source. `date` can be an estimate date or a note.
			const properties = {
				records: [
					{ sqft: 984, value: 370000, label: '1022 Curran', set: CheckboxValues.ZE, date: '04/18/2025'},
					{ sqft: 984, value: 377600, label: '1022 Curran', set: CheckboxValues.RE, date: '04/18/2025'},
					{ sqft: 1725, value: 504000, label: '10th St', set: CheckboxValues.ZE, date: '04/18/2025 Townhouse'},
					{ sqft: 1631, value: 870100, label: '1176 Atlantic', set: CheckboxValues.OTHER, date: '04/19/2025 Collateral Analytics'},
					{ sqft: 1631, value: 595180, label: '1176 Atlantic', set: CheckboxValues.RE, date: '04/20/2025'}, 
					{ sqft: 1631, value: 540100, label: '1176 Atlantic', set: CheckboxValues.ZE, date: '04/19/2025'},
					{ sqft: 2038, value: 859900, label: '1171B State', set: CheckboxValues.RE, date: '04/19/2025'},
					{ sqft: 2038, value: 799900, label: '1171B State', set: CheckboxValues.RE, date: '05/22/2025'},
					{ sqft: 2038, value: 848200, label: '1171B State', set: CheckboxValues.ZE, date: '04/19/2025'},
					{ sqft: 2038, value: 804300, label: '1171B State', set: CheckboxValues.ZE, date: '05/22/2025'},
					{ sqft: 1375, value: 515000, label: '461 Trabert', set: CheckboxValues.ZE, date: '04/18/2025'},
					{ sqft: 1375, value: 533516, label: '461 Trabert', set: CheckboxValues.RE, date: '04/18/2025'},
					{ sqft: 1116, value: 851000, label: '1176 State', set: CheckboxValues.OTHER, date: '04/15/2025 Collateral Analytics'}, 
					{ sqft: 1116, value: 327400, label: '1176 State', set: CheckboxValues.ZE, date: '03/27/2025'},
					{ sqft: 1116, value: 479900, label: '1176 State', set: CheckboxValues.RE, date: '04/18/2025'}, 
					{ sqft: 1766, value: 353900, label: '1176 State', set: CheckboxValues.ZE, date: '04/18/2025'},
					{ sqft: 1944, value: 680040, label: '1176 State', set: CheckboxValues.OTHER, date: '$350/sqft (Self-calc)'},
					{ sqft: 1766, value: 618100, label: '1176 State', set: CheckboxValues.OTHER, date: '$350/sqft (Self-calc)'},
					{ sqft: 1116, value: 423189, label: '1176 State', set: CheckboxValues.OTHER, date: '05/11/2025 Redfin'},
					{ sqft: 1116, value: 557700, label: '1176 State', set: CheckboxValues.RE, date: '05/17/2025'}, 
					{ sqft: 1052, value: 495200, label: '1175 State', set: CheckboxValues.RE, date: '04/19/2025'},
					{ sqft: 1052, value: 330800, label: '1175 State', set: CheckboxValues.ZE, date: '04/19/2025'},
					{ sqft: 1016, value: 488400, label: '1180 State', set: CheckboxValues.RE, date: '04/19/2025'},
					{ sqft: 1016, value: 384200, label: '1180 State', set: CheckboxValues.ZE, date: '04/19/2025'},
					{ sqft: 1276, value: 484180, label: '1186 State', set: CheckboxValues.RE, date: '04/19/2025'},
					{ sqft: 1276, value: 487400, label: '1186 State', set: CheckboxValues.ZE, date: '04/19/2025'},
					{ sqft: 2263, value: 578621, label: '1185 State', set: CheckboxValues.RE, date: '04/19/2025'}, 
					{ sqft: 2263, value: 538694, label: '1185 State', set: CheckboxValues.RE, date: '05/11/2025'}, 
					{ sqft: 2263, value: 570257, label: '1185 State', set: CheckboxValues.OTHER, date: '05/11/2025 Redfin'},
					{ sqft: 2263, value: 459900, label: '1185 State', set: CheckboxValues.ZE, date: '04/19/2025'},
					{ sqft: 1500, value: 570000, label: '1189 State', set: CheckboxValues.RE, date: '04/19/2025'},
					{ sqft: 1500, value: 622800, label: '1189 State', set: CheckboxValues.ZE, date: '04/19/2025'},
					{ sqft: 1715, value: 492949, label: '1190 State', set: CheckboxValues.RE, date: '04/19/2025'},
					{ sqft: 1495, value: 506400, label: '1190 State', set: CheckboxValues.ZE, date: '04/19/2025'},
					{ sqft: 2038, value: 643600, label: '1199 State', set: CheckboxValues.RE, date: '04/19/2025'},
					{ sqft: 2038, value: 613700, label: '1199 State', set: CheckboxValues.ZE, date: '04/19/2025'},
					{ sqft: 1715, value: 662200, label: '1190 Francis', set: CheckboxValues.RE, date: '04/19/2025'},
					{ sqft: 1715, value: 577400, label: '1190 Francis', set: CheckboxValues.ZE, date: '04/19/2025'},
					{ sqft: 1786, value: 889000, label: '1186B Francis', set: CheckboxValues.RE, date: '05/10/2025'},
					{ sqft: 1786, value: 871000, label: '1186B Francis', set: CheckboxValues.ZE, date: '05/10/2025'},
					{ sqft: 1608, value: 418000, label: '1170 Atlantic', set: CheckboxValues.RE, date: '04/20/2025'},
					{ sqft: 1888, value: 649900, label: '1190 Atlantic', set: CheckboxValues.ZE, date: '04/20/2025'},
					{ sqft: 1888, value: 649900, label: '1190 Atlantic', set: CheckboxValues.RE, date: '04/20/2025'}, 
					{ sqft: 1362, value: 549250, label: '1229 State', set: CheckboxValues.RE, date: '05/03/2025'},
					{ sqft: 1362, value: 555700, label: '1229 State', set: CheckboxValues.ZE, date: '05/03/2025'},
					{ sqft: 1657, value: 641941, label: '1251 State', set: CheckboxValues.RE, date: '05/03/2025'},
					{ sqft: 1657, value: 586400, label: '1251 State', set: CheckboxValues.ZE, date: '05/03/2025'},
					{ sqft: 1353, value: 577000, label: '1244 Atlantic', set: CheckboxValues.RE, date: '05/03/2025'},
					{ sqft: 1353, value: 600000, label: '1244 Atlantic', set: CheckboxValues.ZE, date: '05/03/2025'},
					{ sqft: 1030, value: 421200, label: '1179 Mecaslin', set: CheckboxValues.ZE, date: '04/19/2025'},
					{ sqft: 1030, value: 434578, label: '1179 Mecaslin', set: CheckboxValues.RE, date: '04/19/2025'},
					{ sqft: 1050, value: 427572, label: '1185 Mecaslin', set: CheckboxValues.RE, date: '04/20/2025'},
				],
			};
			
			// Stores data points for dynamically generated reference lines.
			let lines = {
				records: [ 
					{ sqft: MIN_SQFT_PLACEHOLDER, value: 628739, label: 'AlphaMap Avg Value', set: ReferenceLineTypes.AM, date: '2024 data (source)'}, 
					{ sqft: MAX_SQFT_PLACEHOLDER, value: 628739, label: 'AlphaMap Avg Value', set: ReferenceLineTypes.AM, date: '2024 data (source)'}, 
				],
			};
			
			// Stores calculated average data (sqft, value, set key, display label) for RE, ZE, and OTHER sets.
			let avgs = { 
				records: [], 
			};

			// --- Helper Functions ---

			// Retrieves a display label for a given set key from the `sets` configuration.
			function labelMap(setKey) {
				return sets[setKey]?.label || sets.DEFAULT.label;
			}
			
			// Retrieves a color for a given set key from the `sets` configuration.
			function colorMap(setKey) {
				return sets[setKey]?.color || sets.DEFAULT.color;
			}

			// Determines if a record's set key qualifies as 'OTHER' (i.e., not RE or ZE).
			function isOtherSet(recordSetKey) { 
				return recordSetKey !== CheckboxValues.RE && recordSetKey !== CheckboxValues.ZE;
			}
		
			// Converts an RGBA color string to have full opacity (alpha = 1) for borders.
			function getOpaqueBorderColor(rgbaColor) {
				if (typeof rgbaColor === 'string' && rgbaColor.startsWith('rgba(')) { 
					return rgbaColor.replace(/, [\d\.]+([,\)])/, ', 1$1'); // Sets alpha to 1
				}
				return rgbaColor; 
			}
			
			// --- Data Processing and Reference Line Generation ---

			// Replaces placeholder sqft values in `lines.records` with actual min/max from `properties.records`.
			function updateLineDataPlaceholders() {
				if (properties.records.length === 0) {
					console.warn("Properties data is empty; cannot update line placeholders.");
					return;
				}
				const allSqfts = properties.records.map(record => record.sqft);
				const smallestSqft = parseFloat(Math.min(...allSqfts).toPrecision(2));
				const largestSqft = parseFloat(Math.max(...allSqfts).toPrecision(2));

				lines.records.forEach(record => {
					if (record.sqft === MIN_SQFT_PLACEHOLDER) record.sqft = smallestSqft;
					if (record.sqft === MAX_SQFT_PLACEHOLDER) record.sqft = largestSqft;
				});
			}

			// Creates vertical lines on the chart for each assessment size, showing a PPSF-based value range.
			function createVerticalAssessmentLines(referencePPSF) {
				if (isNaN(referencePPSF) || referencePPSF === 0) {
					console.warn("Invalid referencePPSF provided for vertical assessment lines. Value:", referencePPSF);
					return;
				}
				const minRateFactor = 0.7; // 30% below reference PPSF
				const maxRateFactor = 1.2; // 20% above reference PPSF
				const minVerticalRate = (minRateFactor * referencePPSF);
				const maxVerticalRate = (maxRateFactor * referencePPSF);

				assessments.forEach(assessment => {
					const pointLabelMin = `${labelMap(assessment.set)} @ $${minVerticalRate.toFixed(0)}/sf`;
					const pointLabelMax = `${labelMap(assessment.set)} @ $${maxVerticalRate.toFixed(0)}/sf`;
					// Each assessment size results in two points, forming a vertical line segment.
					// `label` is for tooltips; `set` for styling; `date` for extra tooltip info.
					lines.records.push({
						sqft: assessment.sqft, 
						value: assessment.sqft * minVerticalRate, 
						label: pointLabelMin, 
						set: assessment.set, 
						date: `Range based on $${referencePPSF.toFixed(0)}/sf reference` 
					});
					lines.records.push({
						sqft: assessment.sqft, 
						value: assessment.sqft * maxVerticalRate, 
						label: pointLabelMax, 
						set: assessment.set, 
						date: `Range based on $${referencePPSF.toFixed(0)}/sf reference`
					});
				});
			}

			// Creates lines representing average Price Per Square Foot (PPSF) for RE, ZE, OTHER sets.
			// These lines span the observed sqft range on the chart.
			function createAverageValueLines() {
				if (properties.records.length === 0) {
					console.warn("Properties data is empty; cannot create average value lines.");
					return;
				}
				const allSqftsNumeric = properties.records.map(r => r.sqft).filter(s => typeof s === 'number');
				if (allSqftsNumeric.length === 0) {
					console.warn("No numeric sqft data in properties; cannot determine chart range for average lines.");
					return;
				}
				const minChartSqft = Math.min(...allSqftsNumeric);
				const maxChartSqft = Math.max(...allSqftsNumeric);
				
				avgs.records.forEach(avgRecord => {
					if (avgRecord.sqft === 0) {
						console.warn(`Average sqft is 0 for set "${labelMap(avgRecord.set)}"; cannot calculate PPSF line.`);
						return;
					}
					const ppsf = (avgRecord.value / avgRecord.sqft);
					const pointLabel = `$${ppsf.toFixed(0)}/sf`; // PPSF for this specific average line for tooltip.
					// Each average (RE, ZE, OTHER) gets two points defining a line segment.
					lines.records.push({
						sqft: minChartSqft, 
						value: minChartSqft * ppsf, 
						label: pointLabel, 
						set: avgRecord.set, // Set key (RE, ZE, OTHER) for styling
						date: avgRecord.label // Display label for this average (e.g., "RealEstimate Average")
					});
					lines.records.push({
						sqft: maxChartSqft, 
						value: maxChartSqft * ppsf, 
						label: pointLabel, 
						set: avgRecord.set, 
						date: avgRecord.label
					});
				});
			}
			
			// Populates `lines.records` with all necessary data points for various reference lines.
			function AddAssessmentReferenceLines() {
				updateLineDataPlaceholders(); // Process initial AlphaMap line.

				// Use the PPSF from the first available average in `avgs.records` as a reference for vertical assessment lines.
				if (avgs.records.length > 0 && avgs.records[0]?.sqft !== 0 && typeof avgs.records[0]?.value === 'number' && typeof avgs.records[0]?.sqft === 'number') {
					const firstAvgSetPpsf = avgs.records[0].value / avgs.records[0].sqft;
					createVerticalAssessmentLines(firstAvgSetPpsf);
				} else {
					console.warn("Could not generate vertical assessment lines: Default average data for PPSF calculation is missing or invalid in `avgs.records`.");
				}
				
				createAverageValueLines(); // Create lines based on calculated RE, ZE, OTHER averages.
				console.log('Lines records fully populated:', lines.records);
			}

			// Calculates and stores average sqft and value for RE, ZE, and OTHER property sets in `avgs.records`.
			function findSetAverages(propertiesSource) {
				const setKeysToAverage = [CheckboxValues.RE, CheckboxValues.ZE, CheckboxValues.OTHER];
				setKeysToAverage.forEach(setKey => {
					let recordsForSet;
					if (setKey === CheckboxValues.OTHER) {
						recordsForSet = propertiesSource.records.filter(record => isOtherSet(record.set));
					} else {
						recordsForSet = propertiesSource.records.filter(record => record.set === setKey);
					}

					if (recordsForSet.length > 0) {
						const totalSqft = recordsForSet.reduce((sum, record) => sum + record.sqft, 0);
						const avgSqft = Math.round(totalSqft / recordsForSet.length);
						const totalValue = recordsForSet.reduce((sum, record) => sum + record.value, 0);
						const avgValue = Math.round(totalValue / recordsForSet.length);
						
						// `set` stores the key (RE, ZE, OTHER) for internal use.
						// `label` stores the display-friendly name for this average (e.g., "RealEstimate Average").
						avgs.records.push({
							sqft: avgSqft, 
							value: avgValue, 
							set: setKey, 
							label: labelMap(setKey) + AVG_SUFFIX, 
							date: '' // Date is not applicable for these aggregate averages
						}); 
					}
				});
				console.log('Calculated Set Averages:', avgs.records);
			}

			// Calculates overall average sqft and value for the property sets currently selected via checkboxes.
			function calculateAveragePropertyMetrics(propertiesSource, selectedCheckboxKeys) { 
				if (!propertiesSource?.records || propertiesSource.records.length === 0 || selectedCheckboxKeys.length === 0) {
					return { averageSqft: 0, averageValue: 0 }; 
				}
				
				let relevantRecords = [];
				// Gather records only for selected primary types (RE, ZE, OTHER) from checkboxes.
				// This avoids including data from non-primary data types (like reference lines) in the overall average.
				selectedCheckboxKeys.forEach(key => {
					if (key === CheckboxValues.OTHER) {
						relevantRecords.push(...propertiesSource.records.filter(r => isOtherSet(r.set)));
					} else if (key === CheckboxValues.RE || key === CheckboxValues.ZE) { 
						relevantRecords.push(...propertiesSource.records.filter(r => r.set === key));
					}
				});
				// Remove duplicates, though unlikely with current data structure.
				relevantRecords = Array.from(new Set(relevantRecords.map(JSON.stringify))).map(JSON.parse);

				if (relevantRecords.length === 0) return { averageSqft: 0, averageValue: 0 };

				const totalSqft = relevantRecords.reduce((sum, record) => sum + record.sqft, 0);
				const totalValue = relevantRecords.reduce((sum, record) => sum + record.value, 0);
				const count = relevantRecords.length;
				
				const averageSqft = count > 0 ? totalSqft / count : 0;
				const averageValue = count > 0 ? totalValue / count : 0;
				
				return {
					averageSqft: parseFloat(averageSqft.toPrecision(4)), // Standardized precision
					averageValue: parseFloat(averageValue.toPrecision(7)), // Standardized precision
				};
			}
			
			// --- Chart Dataset Creation Functions ---

			// Creates a Chart.js dataset object for scatter points (property estimates).
			function createScatterDataset(setTypeKey) { 
				let filteredData;
				if (setTypeKey === CheckboxValues.OTHER) {
					filteredData = properties.records.filter(record => isOtherSet(record.set));
				} else {
					filteredData = properties.records.filter(record => record.set === setTypeKey);
				}
				if (filteredData.length === 0) return null; 
				
				return {
					type: 'scatter',
					label: labelMap(setTypeKey), // Legend label for the series (e.g., "RealEstimate")
					data: filteredData.map(record => ({
						x: record.sqft,
						y: record.value,
						label: record.label, // Point-specific: property address for tooltip
						date: record.date,   // Point-specific: estimate date/note for tooltip
					})),
					backgroundColor: colorMap(setTypeKey),
					borderColor: getOpaqueBorderColor(colorMap(setTypeKey)), 
					pointRadius: 5,
					pointHoverRadius: 8,
				};
			}
 
			// Creates a Chart.js dataset object for line series (reference lines).
			function createLineDataset(lineSetKey) { 
				const filteredLineData = lines.records.filter(record => record.set === lineSetKey);
				if (filteredLineData.length === 0) return null; 

				let legendLabel = labelMap(lineSetKey); 
				// Append suffix for average lines associated with RE/ZE checkboxes (e.g., "RealEstimate Average")
				if (lineSetKey === CheckboxValues.RE || lineSetKey === CheckboxValues.ZE) {
					legendLabel += AVG_SUFFIX; 
				}
				// For other lines (AM, OLD, NEW, REAL), labelMap provides the direct legend label.
				
				return {
					type: 'line',
					label: legendLabel, // Legend label for the entire line series
					data: filteredLineData.map(record => ({
						x: parseFloat(record.sqft), 
						y: parseFloat(record.value), 
						label: record.label, // Point-specific label (e.g., "$XXX/sf") for tooltip
						date: record.date,   // Point-specific additional info (e.g., "2024 data") for tooltip
					})),
					fill: false,
					borderColor: colorMap(lineSetKey),
					backgroundColor: colorMap(lineSetKey), // Used for the legend color box
					tension: 0, // Straight lines
					pointRadius: 1, // Small points on the line
					borderWidth: 2, 
					pointHoverRadius: 3,
					showLine: true,
				};
			}
			
			// --- Chart Initialization and Update Logic ---
			
			// Perform initial data processing: calculate averages and generate reference line data.
			findSetAverages(properties); 
			AddAssessmentReferenceLines(); 

			let scatterChart; // Holds the Chart.js instance.
			
			// Main function to update and redraw the chart based on current checkbox selections.
			function updateChart() {
				const datasets = [];
				const selectedCheckboxKeys = Array.from(document.querySelectorAll(chartFilterCheckboxes))
											.filter(cb => cb.checked)
											.map(cb => cb.value);
				console.log('Selected checkbox values for chart update:', selectedCheckboxKeys);

				// Create Scatter Datasets based on selected checkboxes (RE, ZE, OTHER)
				[CheckboxValues.RE, CheckboxValues.ZE, CheckboxValues.OTHER].forEach(setKey => {
					if (selectedCheckboxKeys.includes(setKey)) {
						const scatterDataset = createScatterDataset(setKey);
						if (scatterDataset) datasets.push(scatterDataset);
					}
				});
				
				// Create Line Datasets if "Reference Lines" (RL) checkbox is selected
				if (selectedCheckboxKeys.includes(CheckboxValues.RL)) {
					// Average lines for RE & ZE (only if RE or ZE main checkbox is also selected)
					[CheckboxValues.RE, CheckboxValues.ZE].forEach(setKey => {
						if (selectedCheckboxKeys.includes(setKey)) { 
							const lineDataset = createLineDataset(setKey); 
							if (lineDataset) datasets.push(lineDataset);
						}
					});

					// Dedicated reference lines (AM, and those based on 'assessments' array - OLD, NEW, REAL)
					const dedicatedRefLineKeys = [ReferenceLineTypes.AM, ...assessmentLineSetKeys];
					dedicatedRefLineKeys.forEach(setKey => {
                        // Avoid duplicating RE/ZE average lines if they were already added
                        const isReOrZeAvgLineAlreadyAdded = (setKey === CheckboxValues.RE || setKey === CheckboxValues.ZE) && selectedCheckboxKeys.includes(setKey);
                        if (!isReOrZeAvgLineAlreadyAdded) {
                            const lineDataset = createLineDataset(setKey);
                            if (lineDataset) datasets.push(lineDataset);
                        }
					});
				}

				// Chart.js configuration object
				const chartConfig = { 
					type: 'scatter', 
					data: { datasets: datasets },
					options: {
						responsive: true,
						maintainAspectRatio: true,
						scales: {
							x: {
								type: 'linear', position: 'bottom',
								title: { display: true, text: 'Assessed Square Feet', font: { size: 16, family: 'Arial' }, padding: 8 },
								ticks: { beginAtZero: true, font: { family: 'Arial', size: 12 } },
							},
							y: {
								type: 'linear', position: 'left',
								title: { display: true, text: 'Estimated Value', font: { size: 16, family: 'Arial' }, padding: 8 },
								ticks: { beginAtZero: true, font: { family: 'Arial', size: 12 }, callback: (v) => v >= 1000 ? `${v/1000}K` : v.toLocaleString() },
							},
						},
						plugins: { 
							title: { display: true, text: datasets.length > 0 ? 'Sqft vs. Value Estimates' : 'Sqft vs. Value (No data selected)', font: { size: 18, family: 'Arial', weight: 'bold' }, padding: { top:10, bottom:20 } },
							tooltip: {
								callbacks: {
									// Defines content for each line in the tooltip body
									label: function (context) {
										let tooltipLabel = context.dataset.label || ''; // Series name (e.g., "RealEstimate")
										if (tooltipLabel) tooltipLabel += ': ';
										tooltipLabel += `${context.parsed.x} sq ft for $${context.parsed.y >= 1000 ? (context.parsed.y/1000).toFixed(0)+'K' : context.parsed.y.toLocaleString()}`;
										
										// Add point-specific details (e.g., address for scatter, $/sf for lines)
										if (context.raw?.label) tooltipLabel += ` - ${context.raw.label}`; 
										
										// Add date/note if available and not already part of the point's 'label'
										if (context.raw?.date && (!context.raw.label || !context.raw.label.includes(context.raw.date))) {
											tooltipLabel += ` (${context.raw.date})`;
										}
										return tooltipLabel;
									},
									// Defines the title of the tooltip
									title: function (context) {
										const firstPoint = context[0];
										// For scatter points, title is property address, potentially with date if distinct.
										if (firstPoint?.dataset.type === 'scatter' && firstPoint.raw?.label) {
											let title = firstPoint.raw.label; // Address
											if (firstPoint.raw.date && firstPoint.raw.date !== title && !title.includes(firstPoint.raw.date) ) title += ` (${firstPoint.raw.date})`;
											return title;
										}
										// For line points, title is the line's main legend label (e.g., "RealEstimate Average").
										if (firstPoint?.dataset.type === 'line' && firstPoint.dataset.label) {
											return firstPoint.dataset.label; 
										}
										return ''; // Default empty title
									},
								},
								backgroundColor: 'rgba(0, 0, 0, 0.85)', 
								titleFont: { family: 'Arial', size: 14, weight: 'bold' }, 
								bodyFont: { family: 'Arial', size: 12 },
								borderColor: '#555', 
								borderWidth: 1, 
								cornerRadius: 4, 
								padding: 10, 
								displayColors: false, // Hides the small color box in tooltips
							},
							legend: { 
								display: true, 
								position: 'top', 
								labels: { font: { family: 'Arial', size: 12 }, boxWidth: 20, padding: 10 }
							}, 
							datalabels: { 
								display: false // Data labels on points are generally too noisy for this type of scatter chart
							}, 
						},
					},
					plugins: [ChartDataLabels], // Register the datalabels plugin globally
				};

				if (scatterChart) scatterChart.destroy(); // Destroy existing chart instance before drawing new one
				scatterChart = new Chart(chartCanvasContext, chartConfig); // Create new chart instance

				// Update the displayed average statistics based on selected checkboxes
				const avgMetrics = calculateAveragePropertyMetrics(properties, selectedCheckboxKeys);
				console.log('Metrics for selected sets:', avgMetrics);
				if (avgMetrics.averageSqft > 0 && avgMetrics.averageValue > 0) {
					const ppsf = (avgMetrics.averageValue / avgMetrics.averageSqft).toPrecision(3);
					statsOutputElement.innerHTML = `Average [ $${ppsf}/sq ft, $${(avgMetrics.averageValue / 1000).toFixed(0)}K, ${avgMetrics.averageSqft.toFixed(0)} sq ft ]`;
				} else {
					statsOutputElement.innerHTML = 'Average [N/A]';
				}
			}
			
			// --- Initial Execution and Event Listeners ---
			
			// Initial chart render on page load
			updateChart();

			// Event listener for checkbox changes to update the chart dynamically
			document.querySelectorAll(chartFilterCheckboxes).forEach((checkbox) => {
				checkbox.addEventListener('change', updateChart);
			});

		</script>
	</body>
</html>
